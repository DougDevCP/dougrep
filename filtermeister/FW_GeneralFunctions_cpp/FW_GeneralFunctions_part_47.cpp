			    ENTITY("&brvbar;",	"\xA6");	// �
			    ENTITY("&bull;",	"\x95");	// � (use � for bullet)
			    ENTITY("&bull2;",	"\x07");	// OEM (bullet style 2)
				ENTITY("&bull3;",	"\x7F");	//  (unofficial; narrow unfilled rectangle)
				ENTITY("&bull4;",	"\x81");	//  (unofficial; wide unfilled rectangle)
                break;
            case 'c':
			    ENTITY("&ccedil;",	"\xE7");	// �
			    ENTITY("&cedil;",	"\xB8");	// �
			    ENTITY("&cent;",	"\xA2");	// �
			    ENTITY("&circ;",	"\x88");	// � (modifier letter circumflex accent)
			    ENTITY("&colone;",	":=");		// := (colon equal)
			    ENTITY("&copy;",	"\xA9");	// �
			    ENTITY("&crarr;",	"\x11\x04");	// OEM (subst. for carriage return arrow)
			    ENTITY("&curren;",	"\xA4");	// �
                break;
            case 'd':
			    ENTITY("&dagger;",	"\x86");	// � (dagger)
			    ENTITY("&deg;",		"\xB0");	// �
			    ENTITY("&divide;",	"\xF7");	// �
                break;
            case 'e':
			    ENTITY("&eacute;",	"\xE9");	// �
			    ENTITY("&ecirc;",	"\xEA");	// �
			    ENTITY("&egrave;",	"\xE8");	// �
			    ENTITY("&empty;",	"\xD8");	// � (use capital O-slash for empty set)
			    ENTITY("&emsp;",	" ");		//   (em-space, use normal space)
			    ENTITY("&ensp;",	" ");		//   (en-space, use normal space)
			    ENTITY("&eth;",		"\xF0");	// �
			    ENTITY("&euml;",	"\xEB");	// �
			    ENTITY("&euro;",	"\x80");	// � (use � for euro sign)
                break;
            case 'f':
			    ENTITY("&female;",	"\x0C");	// OEM (female)
			    ENTITY("&fnof;",	"\x83");	// � (f with hook)
			    ENTITY("&frac12;",	"\xBD");	// �
			    ENTITY("&frac14;",	"\xBC");	// �
			    ENTITY("&frac34;",	"\xBE");	// �
			    ENTITY("&frasl;",	"/");		// / (use / for fraction slash)
                break;
            case 'g':
			    ENTITY("&ge;",		">=");		// >= (synthetic)
			    ENTITY("&gt;",		"\x3E");	// >
                break;
            case 'h':
			    ENTITY("&hellip;",	"\x85");	// � (horizontal ellipsis)
                break;
            case 'i':
			    ENTITY("&iacute;",	"\xED");	// �
			    ENTITY("&ibull2;",	"\x08");	// OEM (inverse bullet style 2)
			    ENTITY("&icirc;",	"\xEE");	// �
			    ENTITY("&iexcl;",	"\xA1");	// �
			    ENTITY("&igrave;",	"\xEC");	// �
			    ENTITY("&image;",	"I");		// I imaginary part (blackletter I)
			    ENTITY("&iquest;",	"\xBF");	// �
			    ENTITY("&iuml;",	"\xEF");	// �
                break;
            case 'l':
			    ENTITY("&laquo;",	"\xAB");	// �
			    ENTITY("&larr;",	"\x1B");	// OEM (left arrow)
			    ENTITY("&ldquo;",	"\x93");	// � (left double quotation mark)
			    ENTITY("&le;",		"<=");		// <= (synthetic)
			    ENTITY("&lowast;",	"*");		// * (use asterisk for low asterisk)
			    ENTITY("&lsaquo;",	"\x8B");	// � (single left angle quotation)
			    ENTITY("&lsquo;",	"\x91");	// � (left single quotation mark)
			    ENTITY("&lt;",		"\x3C");	// <
			    ENTITY("&ltrif;",	"\x11");	// OEM (left-pointing triangle, filled)
                break;
            case 'm':
			    ENTITY("&macr;",	"\xAF");	// � (spacing macron)
			    ENTITY("&male;",	"\x0B");	// OEM (male)
			    ENTITY("&mdash;",	"\x97");	// � (em dash)
			    ENTITY("&micro;",	"\xB5");	// �
			    ENTITY("&middot;",	"\xB7");	// �
			    ENTITY("&minus;",	"\x96");	// - (use en-dash for minus symbol)
			    ENTITY("&mu;",	    "\xB5");	// � (mu, use &micro;)
                break;
            case 'n':
			    ENTITY("&nbsp;",	"\xA0");	//	 (no-break space)
			    ENTITY("&ndash;",	"\x96");	// � (en dash)
			    ENTITY("&ne;",		"!=");		// ? (not equal, use !=)
			    ENTITY("&not;",		"\xAC");	// �
			    ENTITY("&ntilde;",	"\xF1");	// �
                break;
            case 'o':
			    ENTITY("&oacute;",	"\xF3");	// �
			    ENTITY("&ocirc;",	"\xF4");	// �
			    ENTITY("&oelig;",	"\x9C");	// � (small ligature oe)
			    ENTITY("&ograve;",	"\xF2");	// �
			    ENTITY("&oline;",	"\xAF");	// � (overline, use macron)
			    ENTITY("&omicron;",	"o");	    // o (Greek omicron, use Latin o)
			    ENTITY("&ordf;",	"\xAA");	// �
			    ENTITY("&ordm;",	"\xBA");	// �
			    ENTITY("&oslash;",	"\xF8");	// �
			    ENTITY("&otilde;",	"\xF5");	// �
			    ENTITY("&ouml;",	"\xF6");	// �
                break;
            case 'p':
			    ENTITY("&para;",	"\xB6");	// �
			    ENTITY("&permil;",	"\x89");	// � (per mille)
			    ENTITY("&pilcrow;",	"\x14");	// OEM (pilcrow, unfilled paragaph mark)
			    ENTITY("&plusmn;",	"\xB1");	// �
			    ENTITY("&pound;",	"\xA3");	// �
			    ENTITY("&prime;",	"'");		// ' (minutes, feet; use &apos;)
                break;
            case 'q':
			    ENTITY("&quot;",	"\x22");	// "
                break;
            case 'r':
			    ENTITY("&raquo;",	"\xBB");	// �
			    ENTITY("&rarr;",	"\x1A");	// OEM (right arrow)
			    ENTITY("&rdquo;",	"\x94");	// � (right double quotation mark)
			    ENTITY("&real;",	"R");		// R real part (blackletter R)
			    ENTITY("&reg;",		"\xAE");	// �
			    ENTITY("&rsaquo;",	"\x9B");	// � (single right angle quotation)
			    ENTITY("&rsquo;",	"\x92");	// � (right single quotation mark)
                break;
            case 's':
			    ENTITY("&sbquo;",	"\x82");	// � (single low-9 quotation mark)
			    ENTITY("&scaron;",	"\x9A");	// � (small s with caron)
			    ENTITY("&sdot;",	"�");		// � (dot operator)
			    ENTITY("&sect;",	"\xA7");	// �
#if 0
			    ENTITY("&shy;",		"\xAD");	// � (soft hyphen, doesn't work in FM)
#else
			    ENTITY("&shy;",		"");		// � (soft hyphen doesn't break in FM, always use "")
#endif
			    ENTITY("&sim;",		"~");		// ~ (use tilde for 'similar to')
#if 0
				ENTITY("&sup0;",	"\xB0");	// � (unofficial; use &deg; in MS Sans Serif, Courier, Courier New, Fixedsys, System, most fixed-width fonts)
#else
				ENTITY("&sup0;",	"\xBA");	// � (unofficial; use &ordm; in Arial, Lucida Console, most propertional fonts.)
#endif
			    ENTITY("&sup1;",	"\xB9");	// �
			    ENTITY("&sup2;",	"\xB2");	// �
			    ENTITY("&sup3;",	"\xB3");	// �
			    ENTITY("&szlig;",	"\xDF");	// �
                break;
            case 't':
			    ENTITY("&thinsp;",	" ");		//   (thin space, use normal space)
			    ENTITY("&thorn;",	"\xFE");	// �
			    ENTITY("&tilde;",	"\x98");	// � (small tilde)
			    ENTITY("&times;",	"\xD7");	// �
#if 1
			    ENTITY("&trade;",	"\x99");	// � (use � for trademark)
#else
			    ENTITY("&trade;",	"(tm)");	// � (use (tm) for trademark)
#endif
			    ENTITY("&twonotes;", "\x0E");	// OEM (two beamed 16th notes)
                break;
            case 'u':
			    ENTITY("&uacute;",	"\xFA");	// �
			    ENTITY("&uarr;",	"\x18");	// OEM (up arrow)
			    ENTITY("&ucirc;",	"\xFB");	// �
			    ENTITY("&ugrave;",	"\xF9");	// �
			    ENTITY("&uml;",		"\xA8");	// �
			    ENTITY("&uuml;",	"\xFC");	// �
                break;
            case 'v':
			    ENTITY("&varr;",	"\x12");	// OEM (up/down arrow; not ISO)
                break;
            case 'w':
			    ENTITY("&weierp;",	"P");		// P powerset (script P)
                break;
            case 'y':
			    ENTITY("&yacute;",	"\xFD");	// �
			    ENTITY("&yen;",		"\xA5");	// �
			    ENTITY("&yuml;",	"\xFF");	// �
                break;
            case 'z':
			    ENTITY("&zcaron;",	"\x9E");	// � (small z with caron, not official?)
			    ENTITY("&zwj;",		"");		//  zero width joiner (no char)
			    ENTITY("&zwnj;",	"");		//  zero width non-joiner (no char)
                break;
            }//switch
			assert(*s == '&');
			// no entity match: copy the single '&'...
			q = "&"; n = 1;

subst_entity:
            //copy the portion of the entity string value
            //that will fit in the formatted string...
            cbCopied = (unsigned int)min(cbLeft, strlen(q));
subst_entity2:	//entry when cbCopied has already been computed (to copy NULs)
            memcpy(p, q, cbCopied); //use memcpy, not str(n)cpy, to copy internal NULs.
            p += cbCopied;
            cbLeft -= cbCopied;
			s += n - 1;
			#undef ENTITY
		}
        else if (cbLeft > 0) {
            //copy this character verbatim to the formatted string
            *p++ = *s;
            cbLeft--;
        }
        s++;
    } //while
    *p = '\0';  //terminate the formatted string
    return f;
} /*fm_formatString*/


void lockCtlUpdate (int state){

	ctlUpdateLocked = state;
}


int setCtlLabel(int n, char * iText){

    RECT    wRect;

    if (n < 0 || n >= N_CTLS || !gParams->ctl[n].inuse) {
        return FALSE;
    }

    if (gParams->ctl[n].ctlclass != CC_LISTBAR && gParams->ctl[n].ctlclass != CC_COMBOBOX) return false;

    if (iText) {
        strncpy(gParams->ctl[n].label2, (char *)iText, 32+1);
        gParams->ctl[n].label2[32] = '\0';   //ensure null-terminated.
    } else {
        gParams->ctl[n].label2[0] = '\0'; //No text string
    }


    {//scope
        //Resize the static text buddy to exactly fit the text,
        //to minimize problems with overlapping controls...
		SIZE  size = {60,14};
        RECT  r;
        HWND  hWnd = GetDlgItem(fmc.hDlg, IDC_BUDDY2+n);
        HDC   hDC = GetDC(hWnd);
        HFONT hOldFont = (HFONT)SelectObject(hDC, gParams->ctl[n].hFont);
        LPSTR p = formatString(gParams->ctl[n].label2);
        //CAUTION: p points to volatile storage (which will
		//be overwritten by calls to Info(), etc.)!!

        GetTextExtentPoint32(hDC, p, (int)strlen(p), &size);
		if (gParams->ctl[n].sb.maxw2 > 0 && size.cx > gParams->ctl[n].sb.maxw2)
			gParams->ctl[n].sb.w2 = gParams->ctl[n].sb.maxw2;
		else
			gParams->ctl[n].sb.w2 = size.cx;    //text width in pixels
		if (gParams->ctl[n].sb.maxh2 > 0 && size.cy > gParams->ctl[n].sb.maxh2)
			gParams->ctl[n].sb.h2 = gParams->ctl[n].sb.maxh2;
		else
			gParams->ctl[n].sb.h2 = size.cy;    //text height in pixels
        computeBuddy2Pos(n,
                         gParams->ctl[n].xPos,
                         gParams->ctl[n].yPos,
                         gParams->ctl[n].width,
                         gParams->ctl[n].height,
                         &r);
		        
		SetWindowPos(gParams->ctl[n].hBuddy2, NULL,
                     r.left,    //x
                     r.top,     //y
                     r.right,   //w
                     r.bottom,  //h
                     SWP_NOZORDER | SWP_NOACTIVATE | SWP_NOCOPYBITS);
        //Cleanup...
        SelectObject(hDC, hOldFont);
        ReleaseDC(hWnd, hDC);
        //Set the actual control text...
        SetWindowText(hWnd, p);

        //It seems a static text control does not erase the
        //background when it receives a WM_SETTEXT message
        //(maybe because we are handling WM_CTLCOLORSTATIC
        //and setting the background to transparent??), so
        //we brute-force it... (this may be overkill??)
		if (!ctlUpdateLocked){
			if (gParams->ctl[n].enabled){
				GetWindowRect(hWnd, &wRect); 
				ScreenToClient (fmc.hDlg, (LPPOINT)&wRect);
				ScreenToClient (fmc.hDlg, (LPPOINT)&(wRect.right));
				return RedrawWindow(
	#if 0
						//just updating the control window doesn't work :(
						hWnd,   // handle of control window
	#else
						fmc.hDlg,   // handle of entire dialog window
	#endif
	#if 1
						&wRect, // address of structure with update rectangle
	#else
						NULL,   // address of structure with update rectangle, NULL=>entire client area
	#endif
						NULL,   // handle of update region
						RDW_ERASE|RDW_INVALIDATE|RDW_ERASENOW|RDW_UPDATENOW     // array of redraw flags
				   );
			}
		}

    }//scope
   
    return true;

}
